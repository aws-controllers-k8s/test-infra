// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

package generator

import (
	"compress/gzip"
	"fmt"
	"html/template"
	"os"
	"slices"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// Structure for prow job versions stored in
// images_config.yaml
type ImageContext struct {
	ImageRepo string            `yaml:"image_repo"`
	Images    map[string]string `yaml:"images"`
}

// Structure for prow job configurations stored in
// jobs.yaml
type JobsConfig struct {
	AWSServices                   []string `yaml:"aws_services"`
	CarmTestServices              []string `yaml:"carm_test_services"`
	IRSTestServices              []string `yaml:"irs_test_services"`
	SoakTestOnReleaseServiceNames []string `yaml:"soak_test_on_release_service_names"`
	CodegenPresubmitServices      []string `yaml:"code_gen_presubmit_services"`
	RuntimePresubmitServices      []string `yaml:"runtime_presubmit_services"`
	ACKTestPresubmitServices      []string `yaml:"acktest_presubmit_services"`
}

func loadImages(imageConfigPath string) (*ImageContext, error) {

	fileData, err := os.ReadFile(imageConfigPath)
	if err != nil {
		return nil, fmt.Errorf("unable to read file %s: %v", imageConfigPath, err)
	}

	var imageContext *ImageContext
	if err = yaml.Unmarshal(fileData, &imageContext); err != nil {
		return nil, fmt.Errorf("unable to unmarshall imageConfig: %v", err)
	}
	return imageContext, nil
}

func loadConfig(configPath string) (*JobsConfig, error) {
	fileData, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("unable to read file %s: %v", configPath, err)
	}

	var config *JobsConfig
	if err = yaml.Unmarshal(fileData, &config); err != nil {
		return nil, fmt.Errorf("unable to unmarshall imageConfig: %v", err)
	}
	return config, nil
}

func contains(arr []string, s string) bool {
	return slices.Contains(arr, s)
}

func loadTemplates(prowJobType, templateDir string, imageContext *ImageContext, config *JobsConfig) (string, error) {

	templateFiles, err := os.ReadDir(templateDir)
	if err != nil {
		return "", fmt.Errorf("unable to read directory %s: %v", templateDir, err)
	}

	var content strings.Builder

	content.WriteString(fmt.Sprintf("%s:\n", prowJobType))
	data := map[string]interface{}{
		"Config":       config,
		"ImageContext": imageContext,
	}

	for _, file := range templateFiles {
		// templateContent, err := template.ParseFS(filename, imageContext.Images[0])
		fileData, _ := os.ReadFile(fmt.Sprintf("%s/%s", templateDir, file.Name()))
		tmpl, err := template.New(file.Name()).Funcs(template.FuncMap{"contains": contains}).Parse(string(fileData))

		if err != nil {
			panic(err)
		}
		err = tmpl.Execute(&content, data)
		if err != nil {
			panic(err)
		}
		content.WriteString("\n")
	}
	return content.String(), err
}

func generateJobs(templatePath, outputPath string, imageContext *ImageContext, config *JobsConfig) error {
	periodicJobsPath := fmt.Sprintf("%s/periodics", templatePath)
	postsubmitJobsPath := fmt.Sprintf("%s/postsubmits", templatePath)
	presubmitJobsPath := fmt.Sprintf("%s/presubmits", templatePath)

	var prowjobsContent strings.Builder
	prowjobsContent.WriteString("# Autogenerated. Do NOT update Manually.\n")
	prowjobsContent.WriteString(fmt.Sprintf("# Last generated on %v\n", time.Now().Format(time.DateTime)))

	periodicsContent, err := loadTemplates("periodics", periodicJobsPath, imageContext, config)
	if err != nil {
		return err
	}
	postSubmitContent, err := loadTemplates("postsubmits", postsubmitJobsPath, imageContext, config)
	if err != nil {
		return err
	}
	presubmitContent, err := loadTemplates("presubmits", presubmitJobsPath, imageContext, config)
	if err != nil {
		return err
	}

	prowjobsContent.WriteString(fmt.Sprintf("%s%s%s", periodicsContent, postSubmitContent, presubmitContent))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	_, err = file.WriteString(prowjobsContent.String())
	if err != nil {
		return err
	}

	// Generate gzipped version for ConfigMap deployment
	gzipPath := outputPath + ".gz"
	err = gzipFile(outputPath, gzipPath)
	return err
}

func generateLabelSyncConfig(templatePath, outputPath string, config *JobsConfig) error {

	var configContent strings.Builder
	configContent.WriteString("# Autogenerated. Do NOT update Manually\n")
	configContent.WriteString(fmt.Sprintf("# Last generated on %v.\n#\n", time.Now().Format(time.DateTime)))

	tmpl, err := template.ParseFiles(fmt.Sprintf("%s/config/label_sync.tpl", templatePath))
	if err != nil {
		return err
	}
	err = tmpl.Execute(&configContent, config)
	if err != nil {
		return err
	}
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}

	_, err = file.WriteString(configContent.String())
	return err
}

func addAutoGenHeader(content *strings.Builder) {
	content.WriteString("# Autogenerated. Do NOT update Manually\n")
	fmt.Fprintf(content, "# Last generated on %v.\n#\n", time.Now().Format(time.DateTime))
}

// gzipFile compresses a file using gzip
func gzipFile(sourcePath, destPath string) error {
	data, err := os.ReadFile(sourcePath)
	if err != nil {
		return fmt.Errorf("failed to read source file: %v", err)
	}

	destFile, err := os.Create(destPath)
	if err != nil {
		return fmt.Errorf("failed to create destination file: %v", err)
	}
	defer destFile.Close()

	gzipWriter := gzip.NewWriter(destFile)
	defer gzipWriter.Close()

	_, err = gzipWriter.Write(data)
	return err
}

// Generate will generate labels or jobs, depending on variable "what" is.
// what: can be either labels or jobs.
func Generate(what, jobsConfigPath, imagesConfigPath, templatePath, outputPath string) error {
	config, err := loadConfig(jobsConfigPath)
	if err != nil {
		return err
	}

	imageContext, err := loadImages(imagesConfigPath)
	if err != nil {
		return err
	}

	switch what {
	case "jobs":
		err = generateJobs(templatePath, outputPath, imageContext, config)
	case "labels":
		err = generateLabelSyncConfig(templatePath, outputPath, config)
	}
	return err
}

func GenerateAgentWorkflows(imagesConfigPath, templatePath, outputPath string) error {
	imageContext, err := loadImages(imagesConfigPath)
	if err != nil {
		return err
	}

	data := map[string]interface{}{
		"ImageContext": imageContext,
	}

	templateFiles, err := os.ReadDir(templatePath)
	if err != nil {
		return fmt.Errorf("unable to read directory %s: %v", templatePath, err)
	}

	var content strings.Builder
	addAutoGenHeader(&content)
	content.WriteString("workflows:\n")

	for _, file := range templateFiles {
		fileData, _ := os.ReadFile(fmt.Sprintf("%s/%s", templatePath, file.Name()))
		tmpl, err := template.New(file.Name()).Funcs(template.FuncMap{"contains": contains}).Parse(string(fileData))

		if err != nil {
			panic(err)
		}
		err = tmpl.Execute(&content, data)
		if err != nil {
			panic(err)
		}
		content.WriteString("\n")
	}

	file, err := os.Create(outputPath)
	if file != nil {
		defer file.Close()
	}
	if err != nil {
		return err
	}

	_, err = file.WriteString(content.String())
	return err
}

func GeneratePlugins(
	imagesConfigPath,
	templatePath,
	outputPath string,
) ([]string, error) {
	imageContext, err := loadImages(imagesConfigPath)
	if err != nil {
		return nil, err
	}

	data := map[string]interface{}{
		"ImageContext": imageContext,
	}

	generatedFiles := make([]string, 0)
	for pluginName := range imageContext.Images {

		templateDir := fmt.Sprintf("%s/%s", templatePath, pluginName)
		outputDir := fmt.Sprintf("%s/%s", outputPath, pluginName)

		templateFiles, err := os.ReadDir(templateDir)
		if err != nil {
			return nil, fmt.Errorf("unable to read directory %s: %v", templateDir, err)
		}
		for _, file := range templateFiles {
			var content strings.Builder
			addAutoGenHeader(&content)

			fileData, _ := os.ReadFile(fmt.Sprintf("%s/%s", templateDir, file.Name()))
			tmpl, err := template.New(file.Name()).Funcs(template.FuncMap{"contains": contains}).Parse(string(fileData))

			if err != nil {
				panic(err)
			}
			err = tmpl.Execute(&content, data)
			if err != nil {
				panic(err)
			}

			outputFileName := strings.TrimSuffix(file.Name(), ".tpl") + ".yaml"
			templateOutputPath := fmt.Sprintf("%s/%s", outputDir, outputFileName)
			file, err := os.Create(templateOutputPath)
			if file != nil {
				defer file.Close()
			}
			if err != nil {
				return nil, err
			}

			_, err = file.WriteString(content.String())
			if err != nil {
				return nil, err
			}

			generatedFiles = append(generatedFiles, templateOutputPath)
		}
	}

	return generatedFiles, nil
}
