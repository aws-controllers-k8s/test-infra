// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

package generator

import (
	"fmt"
	"html/template"
	"os"
	"slices"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// Structure for prow job versions stored in
// images_config.yaml
type ImageContext struct {
	ImageRepo string            `yaml:"image_repo"`
	Images    map[string]string `yaml:"images"`
}

// Structure for prow job configurations stored in
// jobs.yaml
type Config struct {
	AWSServices                   []string `yaml:"aws_services"`
	CarmTestServices              []string `yaml:"carm_test_services"`
	SoakTestOnReleaseServiceNames []string `yaml:"soak_test_on_release_service_names"`
	CodegenPresubmitServices      []string `yaml:"code_gen_presubmit_services"`
	RuntimePresubmitServices      []string `yaml:"runtime_presubmit_services"`
	ACKTestPresubmitServices      []string `yaml:"acktest_presubmit_services"`
}

func loadImages(imageConfigPath string) (*ImageContext, error) {

	fileData, err := os.ReadFile(imageConfigPath)
	if err != nil {
		return nil, fmt.Errorf("unable to read file %s: %v", imageConfigPath, err)
	}

	var imageContext *ImageContext
	if err = yaml.Unmarshal(fileData, &imageContext); err != nil {
		return nil, fmt.Errorf("unable to unmarshall imageConfig: %v", err)
	}
	return imageContext, nil
}

func loadConfig(configPath string) (*Config, error) {
	fileData, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("unable to read file %s: %v", configPath, err)
	}

	var config *Config
	if err = yaml.Unmarshal(fileData, &config); err != nil {
		return nil, fmt.Errorf("unable to unmarshall imageConfig: %v", err)
	}
	return config, nil
}

func contains(arr []string, s string) bool {
	return slices.Contains(arr, s)
}

func loadTemplates(prowJobType, templateDir string, imageContext *ImageContext, config *Config) (string, error) {

	templateFiles, err := os.ReadDir(templateDir)
	if err != nil {
		return "", fmt.Errorf("unable to read directory %s: %v", templateDir, err)
	}

	var content strings.Builder

	content.WriteString(fmt.Sprintf("%s:\n", prowJobType))
	data := map[string]interface{}{
		"Config":       config,
		"ImageContext": imageContext,
	}

	for _, file := range templateFiles {
		// templateContent, err := template.ParseFS(filename, imageContext.Images[0])
		fileData, _ := os.ReadFile(fmt.Sprintf("%s/%s", templateDir, file.Name()))
		tmpl, err := template.New(file.Name()).Funcs(template.FuncMap{"contains": contains}).Parse(string(fileData))

		if err != nil {
			panic(err)
		}
		err = tmpl.Execute(&content, data)
		if err != nil {
			panic(err)
		}
		content.WriteString("\n")
	}
	return content.String(), err
}

func generateJobs(templatePath, outputPath string, imageContext *ImageContext, config *Config) error {
	periodicJobsPath := fmt.Sprintf("%s/periodics", templatePath)
	postsubmitJobsPath := fmt.Sprintf("%s/postsubmits", templatePath)
	presubmitJobsPath := fmt.Sprintf("%s/presubmits", templatePath)

	var prowjobsContent strings.Builder
	prowjobsContent.WriteString("# Autogenerated. Do NOT update Manually.\n")
	prowjobsContent.WriteString(fmt.Sprintf("# Last generated on %v\n",  time.Now().UTC()))

	periodicsContent, err := loadTemplates("periodics", periodicJobsPath, imageContext, config)
	if err != nil {
		return err
	}
	postSubmitContent, err := loadTemplates("postsubmits", postsubmitJobsPath, imageContext, config)
	if err != nil {
		return err
	}
	presubmitContent, err := loadTemplates("presubmits", presubmitJobsPath, imageContext, config)
	if err != nil {
		return err
	}

	prowjobsContent.WriteString(fmt.Sprintf("%s%s%s", periodicsContent, postSubmitContent, presubmitContent))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	_, err = file.WriteString(prowjobsContent.String())
	return err
}

func generateLabelSyncConfig(templatePath, outputPath string, config *Config) error {

	var configContent strings.Builder
	configContent.WriteString("# Autogenerated. Do NOT update Manually\n")
	configContent.WriteString(fmt.Sprintf("# Last generated on %v.\n#\n", time.Now().UTC()))

	tmpl, err := template.ParseFiles(fmt.Sprintf("%s/config/label_sync.tpl", templatePath))
	if err != nil {
		return err
	}
	err = tmpl.Execute(&configContent, config)
	if err != nil {
		return err
	}
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}

	_, err = file.WriteString(configContent.String())
	return err
}


// Generate will generate labels or jobs, depending on variable "what" is.
// what: can be either labels or jobs.
func Generate(what, jobsConfigPath, imagesConfigPath, templatePath, outputPath string) error {
	config, err := loadConfig(jobsConfigPath)
	if err != nil {
		return err
	}

	imageContext, err := loadImages(imagesConfigPath)
	if err != nil {
		return err
	}

	if what == "jobs" {
		err = generateJobs(templatePath, outputPath, imageContext, config)
	} else if what == "labels" {
		err = generateLabelSyncConfig(templatePath, outputPath, config)
	}
	return err
}